<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="./main.css">
    <title>SwEmu</title>
  </head>
  <body class="disable-select">
    <div>
      <canvas class="disable-select" id="canvas_zoom" width="100vh" height="100vh"></canvas>
      <canvas class="disable-select" id="canvas_static" width="100vh" height="100vh"></canvas>
      <canvas class="disable-select" id="canvas_dynamic" width="100vh" height="100vh" style="background-color: black; border-radius: 10px;"></canvas>
      <canvas class="disable-select" id="canvas_vgamepad" width="100vh" height="100vh"></canvas>
    </div>
    <script type="module">
      // Whatever this warning is, I got it?
      // Error with Permissions-Policy header: Origin trial controlled feature not enabled: 'interest-cohort'.

      import { CustomDraw } from "./CustomDraw.js";
      import { Point, Vector2D } from "./Geometry.js";
      import { MyMath } from "./MyMath.js";
      import { setCookie, getCookie } from "./Cookies.js";
      // Import Games
      import { CoinCollect } from "./games/CoinCollect.js";
      import { PhysicTest } from "./games/PhysicTest.js";
      // Import SystemApplications
      import { HomeScreen } from "./SystemApplications.js"

      // TODO: Change "type" from Button to a Slider (similar to a SeekBar)
      let zoomPressed = false;
      let zoomf = parseFloat(getCookie("zoom"));
      let totalZoom = [0.5, 1.0, 1.5, 2.0].includes(zoomf) ? zoomf : 1;

      if (getCookie("coinHighscore") === null) setCookie("coinHighscore", 0, 7);

      let swemu = {
        screen: {
          width: 630*totalZoom,
          height: 360*totalZoom,
          borderWidth: 50*totalZoom,
          borderHeight: 20*totalZoom,
        },
        joycon: {
          width: 130*totalZoom,
          height: 400*totalZoom,
        }
      };

      let canvas = {
        zoom: document.getElementById("canvas_zoom"),
        static: document.getElementById("canvas_static"),
        dynamic: document.getElementById("canvas_dynamic"),
        vgamepad: document.getElementById("canvas_vgamepad"),
      };
      let context = {
        zoom: canvas.zoom.getContext("2d"),
        static: canvas.static.getContext("2d"),
        dynamic: canvas.dynamic.getContext("2d"),
        vgamepad: canvas.vgamepad.getContext("2d"),
      };
      let draw = {
        zoom: new CustomDraw(canvas.zoom, context.zoom),
        static: new CustomDraw(canvas.static, context.static),
        dynamic: new CustomDraw(canvas.dynamic, context.dynamic),
        vgamepad: new CustomDraw(canvas.vgamepad, context.vgamepad),
      };

      // Zoom
      canvas.zoom.width = 400;//window.innerWidth;
      canvas.zoom.height = 65;//window.innerHeight;

      canvas.zoom.style.position = "absolute";
      canvas.zoom.style.left = "0px";
      canvas.zoom.style.top = "0px";

      // Static
      canvas.static.width = 2*(swemu.joycon.width + swemu.screen.borderWidth) + swemu.screen.width;
      canvas.static.height = swemu.joycon.height;

      canvas.static.style.position = "absolute";
      canvas.static.style.left = (window.innerWidth / 2) - (swemu.screen.width / 2) - (swemu.joycon.width + swemu.screen.borderWidth) + "px";
      canvas.static.style.top = (window.innerHeight / 2) - (swemu.screen.height / 2) - (swemu.screen.borderHeight) + "px";

      // Dynamic
      canvas.dynamic.width = swemu.screen.width;
      canvas.dynamic.height = swemu.screen.height;

      canvas.dynamic.style.position = "absolute";
      canvas.dynamic.style.left = (window.innerWidth / 2) - (swemu.screen.width / 2) + "px";
      canvas.dynamic.style.top = (window.innerHeight / 2) - (swemu.screen.height / 2)+ "px";

      // vGamepad
      canvas.vgamepad.width = window.innerWidth;
      canvas.vgamepad.height = window.innerHeight;

      canvas.vgamepad.style.position = "absolute";
      canvas.vgamepad.style.left = "0px";
      canvas.vgamepad.style.top = "0px";

      let points = {
        zero: new Point(),

        blueJoyConStart: new Point(),
        blueJoyConMid: new Point(swemu.joycon.width / 2, 0),
        blueJoyConEnd: new Point(swemu.joycon.width, swemu.joycon.height),

        displayBorderStart: new Point(swemu.joycon.width, 0),
        displayBorderEnd: new Point(swemu.joycon.width, 0).add(
          new Point(swemu.screen.width, 0).add(
            new Point(swemu.screen.borderWidth, 0).multiply(2).add(
              new Point(0, canvas.static.height)
            )
          )
        ),

        redJoyConStart: new Point(swemu.joycon.width, 0).add(
          new Point(swemu.screen.width, 0).add(
            new Point(swemu.screen.borderWidth, 0).multiply(2)
          )
        ),
        redJoyConMid: new Point(swemu.joycon.width, 0).multiply(1.5).add(
          new Point(swemu.screen.width, 0).add(
            new Point(swemu.screen.borderWidth, 0).multiply(2).add(
              new Point(0, canvas.static.height)
            )
          )
        ),
        redJoyConEnd: new Point(swemu.joycon.width, 0).multiply(2).add(
          new Point(swemu.screen.width, 0).add(
            new Point(swemu.screen.borderWidth, 0).multiply(2).add(
              new Point(0, canvas.static.height)
            )
          )
        ),

        zoomInteractiveFieldStart: new Point(),
        zoomInteractiveFieldEnd: new Point(400, 65),
      };

      let internals = {
        applications: {
          system: {
            homeScreen: HomeScreen,
          },
          external: {
            coinCollect: CoinCollect,
            physicTest: PhysicTest,
            physicTest2: PhysicTest,
            coinCollect2: CoinCollect,
            physicTest3: PhysicTest,
            coinCollect3: CoinCollect,
          }
        }
      }

      let mouse = {
        position: new Point(),
        pressed: false,
        pressedPosition: new Point(),
        released: true,
        releasedPosition: new Point(),
      };
      let gamepads = {
        virtual: {
          axes: [0, 0],
          renderRadius: 120
        },
        real: {},
        output: {
          axes: [0, 0],
          buttons: {
            south: {pressed: false},
            east: {pressed: false},
            west: {pressed: false},
            north: {pressed: false},
            pause: {pressed: false},
          },
        },
        actions: {
          south: false,
          east: false,
          west: false,
          north: false,
          pause: false,
        }
      };
      let render = {
        deltaTime: Date.now(),
        now: Date.now(),
        input: { // Used for debugging, if verbose === true: print delay (in ms) between (mousedown or mouseup or mousemove) and finished render
          verbose: false,
          delay: 0, // debug output (01.05.2023 22:50 => ~10ms (before obstacles and coins))
          now: 0,
          updated: false,
        }
      }

      let renderSwitch = () => {
        // Blue JoyCon
        draw.static.setColor("2d2dd2");
        draw.static.roundedRect(points.blueJoyConStart, points.blueJoyConEnd, 1);
        draw.static.rect(points.blueJoyConMid, points.blueJoyConEnd);

        // Display Border
        draw.static.setColor("2d2d2d");
        draw.static.rect(points.displayBorderStart, points.displayBorderEnd);

        // Red JoyCon
        draw.static.setColor("d22d2d");
        draw.static.roundedRect(points.redJoyConStart, points.redJoyConEnd, 1);
        draw.static.rect(points.redJoyConStart, points.redJoyConMid);
      }

      let gamepadHandler = (event, connecting) => {
        if (connecting) gamepads.real[event.gamepad.index] = navigator.getGamepads()[event.gamepad.index];
        else delete gamepads.real[event.gamepad.index];
      }
      let mouseMoveHandler = (event) => {
        if (render.input.verbose && !render.input.updated) {
          render.input.updated = true;
          render.input.now = Date.now();
        }

        var eventDoc, doc, body;

        event = event || window.event;

        if (event.pageX == null && event.clientX != null) {
            eventDoc = (event.target && event.target.ownerDocument) || document;
            doc = eventDoc.documentElement;
            body = eventDoc.body;

            event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
            event.pageY = event.clientY + (doc && doc.scrollTop  || body && body.scrollTop  || 0) - (doc && doc.clientTop  || body && body.clientTop  || 0);
        }

        mouse.position = new Point(event.pageX, event.pageY);
      }
      let mouseClickHandler = (event) => {
        mouseMoveHandler(event); // Refresh mouse position before updating

        mouse.pressed = event.type === "mousedown";
        mouse.released = event.type === "mouseup";
        if (event.type === "mousedown") mouse.pressedPosition = mouse.position.valueOf();
        else if (event.type === "mouseup") mouse.releasedPosition = mouse.position.valueOf();
      }

      let getZoomInteraction = () => {
        if (mouse.released) {
          zoomPressed = false;
          return;
        }
        if (mouse.pressedPosition.x < points.zoomInteractiveFieldStart.x || mouse.pressedPosition.y < points.zoomInteractiveFieldStart.y) return;
        if (mouse.pressedPosition.x > points.zoomInteractiveFieldEnd.x || mouse.pressedPosition.y > points.zoomInteractiveFieldEnd.y) return;
        if (zoomPressed) return;
        zoomPressed = true;

        let localPressedPosition = new Point(mouse.pressedPosition.x - points.zoomInteractiveFieldStart.x, mouse.pressedPosition.y - points.zoomInteractiveFieldStart.y);

        // TODO: remove buttonCount in the future
        let buttonCount = 4;
        let buttonWidth = (points.zoomInteractiveFieldEnd.x - points.zoomInteractiveFieldStart.x) / buttonCount;
        let pressedButtonId = parseInt(localPressedPosition.x / buttonWidth);

        setCookie("zoom", ["0.5", "1.0", "1.5", "2.0"][pressedButtonId], 7);
        location.reload();
      }
      let renderZoomInteraction = () => {
        let buttonCount = 4;
        let buttonWidth = (points.zoomInteractiveFieldEnd.x - points.zoomInteractiveFieldStart.x) / buttonCount;

        for (let i=0; i<buttonCount; i++) {
          let pi = new Point(buttonWidth*i, 0);
          let pi1 = new Point(buttonWidth*(i+1), 0);

          draw.zoom.setColor("4d4d4d");
          draw.zoom.rect(pi, new Point(0, points.zoomInteractiveFieldEnd.y).add(pi1));

          draw.zoom.setColor("ffffff")
          draw.zoom.text(["0.5x", "1.0x", "1.5x", "2.0x"][i], new Point(buttonWidth/2, 65/2+5).add(pi), 16, null, null, true);

          draw.zoom.setColor("aaaaaa");
          if (i+1 < buttonCount) draw.zoom.line(pi1, new Point(pi1.x, points.zoomInteractiveFieldEnd.y));
        }
      }

      let getVirtualGamepadData = () => {
        if (mouse.released) return;
        gamepads.used = true;

        // Calculate vector from starting to current position and normalize
        gamepads.virtual.dragVector = new Vector2D(mouse.position, mouse.pressedPosition);

        // Calculate "strength" (0 <= strength <= 1 if in .renderRadius)
        gamepads.virtual.dragStrength = gamepads.virtual.dragVector.length() / gamepads.virtual.renderRadius;

        // Normalize vector after calculating .drawStrength or else it'd be 1 / .renderRadius
        gamepads.virtual.dragVector.normalize();

        // Multiply vector with strength only if 0 <= strength <= 1
        if (gamepads.virtual.dragStrength < 1) gamepads.virtual.dragVector.multiply(gamepads.virtual.dragStrength);

        // Apply dragVector values to .axes for easier and more similar (compared to .real gamepads) access
        gamepads.virtual.axes[0] = gamepads.virtual.dragVector.x;
        gamepads.virtual.axes[1] = gamepads.virtual.dragVector.y;

        gamepads.output.axes = gamepads.virtual.axes;
      }
      let getGamepadData = () => {
        let gamepad = navigator.getGamepads()[0];
        if (gamepad === undefined || gamepad === null) return;

        let deadzone = 0.065;
        if (MyMath.abs(gamepad.axes[0]) >= deadzone || MyMath.abs(gamepad.axes[1]) >= deadzone) {
          gamepads.used = true;
          gamepads.output.axes = gamepad.axes;
        }

        gamepads.output.buttons.south = gamepad.buttons[0];
        gamepads.output.buttons.east = gamepad.buttons[1];
        gamepads.output.buttons.west = gamepad.buttons[2];
        gamepads.output.buttons.north = gamepad.buttons[3];
        gamepads.output.buttons.pause = gamepad.buttons[9];
      }
      let renderGamepad = () => {
        if (!gamepads.used) return;
        if (mouse.released) return; // return for now === only draw vgamepad (mouse pressed)

        draw.vgamepad.setColor("ffffff");
        draw.vgamepad.arc(mouse.pressedPosition, gamepads.virtual.renderRadius, false);
        draw.vgamepad.arc(mouse.pressedPosition, gamepads.virtual.renderRadius / 20, false);

        draw.vgamepad.arc(new Point(gamepads.output.axes[0] * gamepads.virtual.renderRadius, gamepads.output.axes[1] * gamepads.virtual.renderRadius).add(mouse.pressedPosition), gamepads.virtual.renderRadius / 3, false);
      }

      // Init listeners
      window.addEventListener("gamepadconnected",    event => {gamepadHandler(event, true );}, false);
      window.addEventListener("gamepaddisconnected", event => {gamepadHandler(event, false);}, false);
      document.onmousemove = mouseMoveHandler;
      document.ontouchmove = mouseMoveHandler;
      document.onmousedown = mouseClickHandler;
      document.ontouchdown = mouseClickHandler;
      document.onmouseup   = mouseClickHandler;
      document.ontouchup   = mouseClickHandler;

      // Static / One-Time render
      renderZoomInteraction();
      renderSwitch();

      let mainRenderer = () => {
        //if (currentGame !== null) requestAnimationFrame(mainRenderer);

        context.vgamepad.clearRect(0, 0, canvas.vgamepad.width, canvas.vgamepad.height);
        context.dynamic.clearRect(0, 0, canvas.dynamic.width, canvas.dynamic.height);

        // Reset .used state every update and let getVirtualGamepadData and getGamepadData update the value manually
        gamepads.used = false;
        gamepads.output.axes = [0, 0];
        getVirtualGamepadData();
        getGamepadData(); // Overwrite virtual data if this exists
        renderGamepad();

        getZoomInteraction();

        if (homeScreen._currentGame !== null) {
          if (homeScreen._paused) homeScreen._currentGame.renderGame(draw, gamepads, render);

          if (gamepads.output.buttons.east.pressed) {
            if (!gamepads.actions.east)
              homeScreen._currentGame.terminateGame();
            gamepads.actions.east = true;
          } else gamepads.actions.east = false;
        }

        homeScreen.render(draw, gamepads, render);

        let now = Date.now();
        render.deltaTime = (now - render.now) / 1000;
        render.now = now;
        if (render.input.verbose && render.input.updated) {
          render.input.delay = Date.now() - render.input.now;
          console.log(render.input.delay);
          render.input.updated = false;
        }

        requestAnimationFrame(mainRenderer);
      }

      let homeScreen = new HomeScreen(swemu);
      homeScreen.init(internals);

      render.now = Date.now();
      requestAnimationFrame(mainRenderer);
    </script>
  </body>
</html>
