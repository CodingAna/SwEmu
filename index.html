<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="./main.css">
    <title>SwEmu</title>
  </head>
  <body class="disable-select">
    <div>
      <canvas class="disable-select" id="canvas_zoom" width="100vh" height="100vh"></canvas>
      <canvas class="disable-select" id="canvas_static" width="100vh" height="100vh"></canvas>
      <canvas class="disable-select" id="canvas_dynamic" width="100vh" height="100vh" style="background-color: black; border-radius: 10px;"></canvas>
      <canvas class="disable-select" id="canvas_vgamepad" width="100vh" height="100vh"></canvas>
    </div>
    <script type="module">
      // Whatever this warning is, I got it?
      // Error with Permissions-Policy header: Origin trial controlled feature not enabled: 'interest-cohort'.

      import { CustomDraw } from "./CustomDraw.js";
      import { Point, Vector2D } from "./Geometry.js";
      import { MyMath } from "./MyMath.js";
      import { setCookie, getCookie } from "./Cookies.js";
      // Import Games
      import { CoinCollect } from "./games/CoinCollect.js";
      import { PhysicTest } from "./games/PhysicTest.js";
      import { HighwayRun } from "./games/HighwayRun.js";
      // Import SystemApplications
      import { HomeScreen } from "./SystemApplications.js"

      // TODO: Change "type" from Button to a Slider (similar to a SeekBar)
      let zoomPressed = false;
      let zoomf = parseFloat(getCookie("zoom"));
      let totalZoom = [1.0, 1.5, 2.0].includes(zoomf) ? zoomf : 1;

      if (getCookie("coinHighscore") === null) setCookie("coinHighscore", 0, 7);

      let swemu = {
        screen: {
          width: 630*totalZoom,
          height: 360*totalZoom,
          borderWidth: 50*totalZoom,
          borderHeight: 20*totalZoom,
        },
        joycon: {
          width: 130*totalZoom,
          height: 400*totalZoom,
        }
      };

      let canvas = {
        zoom: document.getElementById("canvas_zoom"),
        static: document.getElementById("canvas_static"),
        dynamic: document.getElementById("canvas_dynamic"),
        vgamepad: document.getElementById("canvas_vgamepad"),
      };
      let context = {
        zoom: canvas.zoom.getContext("2d"),
        static: canvas.static.getContext("2d"),
        dynamic: canvas.dynamic.getContext("2d"),
        vgamepad: canvas.vgamepad.getContext("2d"),
      };
      let draw = {
        zoom: new CustomDraw(canvas.zoom, context.zoom),
        static: new CustomDraw(canvas.static, context.static),
        dynamic: new CustomDraw(canvas.dynamic, context.dynamic),
        vgamepad: new CustomDraw(canvas.vgamepad, context.vgamepad),
      };

      // Zoom
      canvas.zoom.width = 400;//window.innerWidth;
      canvas.zoom.height = 65;//window.innerHeight;

      canvas.zoom.style.position = "absolute";
      canvas.zoom.style.left = "0px";
      canvas.zoom.style.top = "0px";

      // Static
      canvas.static.width = 2*(swemu.joycon.width + swemu.screen.borderWidth) + swemu.screen.width;
      canvas.static.height = swemu.joycon.height;

      canvas.static.style.position = "absolute";
      canvas.static.style.left = (window.innerWidth / 2) - (swemu.screen.width / 2) - (swemu.joycon.width + swemu.screen.borderWidth) + "px";
      canvas.static.style.top = (window.innerHeight / 2) - (swemu.screen.height / 2) - (swemu.screen.borderHeight) + "px";

      // Dynamic
      canvas.dynamic.width = swemu.screen.width;
      canvas.dynamic.height = swemu.screen.height;

      canvas.dynamic.style.position = "absolute";
      canvas.dynamic.style.left = (window.innerWidth / 2) - (swemu.screen.width / 2) + "px";
      canvas.dynamic.style.top = (window.innerHeight / 2) - (swemu.screen.height / 2)+ "px";

      // vGamepad
      canvas.vgamepad.width = window.innerWidth;
      canvas.vgamepad.height = window.innerHeight;

      canvas.vgamepad.style.position = "absolute";
      canvas.vgamepad.style.left = "0px";
      canvas.vgamepad.style.top = "0px";

      let points = {
        zero: new Point(),

        blueJoyConStart: new Point(),
        blueJoyConMid: new Point(swemu.joycon.width / 2, 0),
        blueJoyConEnd: new Point(swemu.joycon.width, swemu.joycon.height),

        displayBorderStart: new Point(swemu.joycon.width, 0),
        displayBorderEnd: new Point(swemu.joycon.width, 0).add(
          new Point(swemu.screen.width, 0).add(
            new Point(swemu.screen.borderWidth, 0).multiply(2).add(
              new Point(0, canvas.static.height)
            )
          )
        ),

        redJoyConStart: new Point(swemu.joycon.width, 0).add(
          new Point(swemu.screen.width, 0).add(
            new Point(swemu.screen.borderWidth, 0).multiply(2)
          )
        ),
        redJoyConMid: new Point(swemu.joycon.width, 0).multiply(1.5).add(
          new Point(swemu.screen.width, 0).add(
            new Point(swemu.screen.borderWidth, 0).multiply(2).add(
              new Point(0, canvas.static.height)
            )
          )
        ),
        redJoyConEnd: new Point(swemu.joycon.width, 0).multiply(2).add(
          new Point(swemu.screen.width, 0).add(
            new Point(swemu.screen.borderWidth, 0).multiply(2).add(
              new Point(0, canvas.static.height)
            )
          )
        ),

        zoomInteractiveFieldStart: new Point(),
        zoomInteractiveFieldEnd: new Point(400, 65),
      };

      let internals = {
        users: [
          {
            uid: "6468adbc-aa33-4884-99a4-a0eb4bc7e083",
            name: "User 0",
            icon: {
              background: 1,
            },
          },
          {
            uid: "11b2bd00-44df-4b15-93c0-b2759565b9fc",
            name: "User 1",
            icon: {
              background: 0,
            },
          },
        ],
        applications: {
          system: {
            homeScreen: HomeScreen,
          },
          external: {
            coinCollect: CoinCollect,
            physicTest: PhysicTest,
            highwayRun: HighwayRun,
            coinCollect2: CoinCollect,
            highwayRun2: HighwayRun,
            coinCollect3: CoinCollect,
            physicTest2: PhysicTest,
          }
        }
      }

      let mouse = {
        position: new Point(),
        pressed: false,
        pressedPosition: new Point(),
        released: true,
        releasedPosition: new Point(),
      };
      let gamepads = {
        used: {
          any: false,
          axes: {
            any: false,
            left: false,
            right: false,
          },
          buttons: false,
        },
        virtual: {
          axes: [0, 0],
          renderRadius: 120
        },
        real: {},
        output: {
          axes: [0, 0, 0, 0],
          buttons: {
            south: {pressed: false},
            east: {pressed: false},
            west: {pressed: false},
            north: {pressed: false},
            pause: {pressed: false},
            dpad: {
              up: {pressed: false},
              right: {pressed: false},
              left: {pressed: false},
              down: {pressed: false},
            }
          },
        },
        actions: {
          south: false,
          east: false,
          west: false,
          north: false,
          pause: false,
          dpad: {
            up: false,
            right: false,
            left: false,
            down: false,
          }
        }
      };
      let render = {
        deltaTime: Date.now(),
        now: Date.now(),
        input: { // Used for debugging, if verbose === true: print delay (in ms) between (mousedown or mouseup or mousemove) and finished render
          verbose: false,
          delay: 0, // debug output (01.05.2023 22:50 => ~10ms (before obstacles and coins))
          now: 0,
          updated: false,
        }
      }

      let renderSwitch = () => {
        // Blue JoyCon
        draw.static.setColor("00c3e3");
        draw.static.roundedRect(points.blueJoyConStart, points.blueJoyConEnd, 1);
        draw.static.rect(points.blueJoyConMid, points.blueJoyConEnd);

        // Display Border
        draw.static.setColor("414548");
        draw.static.rect(points.displayBorderStart, points.displayBorderEnd);

        // Red JoyCon
        draw.static.setColor("e60012");
        draw.static.roundedRect(points.redJoyConStart, points.redJoyConEnd, 1);
        draw.static.rect(points.redJoyConStart, points.redJoyConMid);
      }

      let gamepadHandler = (event, connecting) => {
        if (connecting) gamepads.real[event.gamepad.index] = navigator.getGamepads()[event.gamepad.index];
        else delete gamepads.real[event.gamepad.index];
      }
      let mouseMoveHandler = (event) => {
        if (render.input.verbose && !render.input.updated) {
          render.input.updated = true;
          render.input.now = Date.now();
        }

        var eventDoc, doc, body;

        event = event || window.event;

        if (event.pageX == null && event.clientX != null) {
            eventDoc = (event.target && event.target.ownerDocument) || document;
            doc = eventDoc.documentElement;
            body = eventDoc.body;

            event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
            event.pageY = event.clientY + (doc && doc.scrollTop  || body && body.scrollTop  || 0) - (doc && doc.clientTop  || body && body.clientTop  || 0);
        }

        mouse.position = new Point(event.pageX, event.pageY);
      }
      let mouseClickHandler = (event) => {
        mouseMoveHandler(event); // Refresh mouse position before updating

        mouse.pressed = event.type === "mousedown";
        mouse.released = event.type === "mouseup";
        if (event.type === "mousedown") mouse.pressedPosition = mouse.position.valueOf();
        else if (event.type === "mouseup") mouse.releasedPosition = mouse.position.valueOf();
      }

      let getZoomInteraction = () => {
        if (mouse.released) {
          zoomPressed = false;
          return;
        }
        if (mouse.pressedPosition.x < points.zoomInteractiveFieldStart.x || mouse.pressedPosition.y < points.zoomInteractiveFieldStart.y) return;
        if (mouse.pressedPosition.x > points.zoomInteractiveFieldEnd.x || mouse.pressedPosition.y > points.zoomInteractiveFieldEnd.y) return;
        if (zoomPressed) return;
        zoomPressed = true;

        let localPressedPosition = new Point(mouse.pressedPosition.x - points.zoomInteractiveFieldStart.x, mouse.pressedPosition.y - points.zoomInteractiveFieldStart.y);

        // TODO: remove buttonCount in the future
        let buttonCount = 3;
        let buttonWidth = (points.zoomInteractiveFieldEnd.x - points.zoomInteractiveFieldStart.x) / buttonCount;
        let pressedButtonId = parseInt(localPressedPosition.x / buttonWidth);

        setCookie("zoom", ["1.0", "1.5", "2.0"][pressedButtonId], 7);
        location.reload();
      }
      let renderZoomInteraction = () => {
        let buttonCount = 3;
        let buttonWidth = (points.zoomInteractiveFieldEnd.x - points.zoomInteractiveFieldStart.x) / buttonCount;

        for (let i=0; i<buttonCount; i++) {
          let pi = new Point(buttonWidth*i, 0);
          let pi1 = new Point(buttonWidth*(i+1), 0);

          draw.zoom.setColor("4d4d4d");
          draw.zoom.rect(pi, new Point(0, points.zoomInteractiveFieldEnd.y).add(pi1));

          draw.zoom.setColor("ffffff")
          draw.zoom.text(["1.0x", "1.5x", "2.0x"][i], new Point(buttonWidth/2, 65/2+5).add(pi), 16, null, null, true);

          draw.zoom.setColor("aaaaaa");
          if (i+1 < buttonCount) draw.zoom.line(pi1, new Point(pi1.x, points.zoomInteractiveFieldEnd.y));
        }
      }

      let getVirtualGamepadData = () => {
        if (mouse.released) return;
        gamepads.used.any = true;
        gamepads.used.axes = {any: true, left: true, right: false};

        // Calculate vector from starting to current position and normalize
        gamepads.virtual.dragVector = new Vector2D(mouse.position, mouse.pressedPosition);

        // Calculate "strength" (0 <= strength <= 1 if in .renderRadius)
        gamepads.virtual.dragStrength = gamepads.virtual.dragVector.length() / gamepads.virtual.renderRadius;

        // Normalize vector after calculating .drawStrength or else it'd be 1 / .renderRadius
        gamepads.virtual.dragVector.normalize();

        // Multiply vector with strength only if 0 <= strength <= 1
        if (gamepads.virtual.dragStrength < 1) gamepads.virtual.dragVector.multiply(gamepads.virtual.dragStrength);

        // Apply dragVector values to .axes for easier and more similar (compared to .real gamepads) access
        gamepads.virtual.axes[0] = gamepads.virtual.dragVector.x;
        gamepads.virtual.axes[1] = gamepads.virtual.dragVector.y;

        gamepads.output.axes = gamepads.virtual.axes;
      }
      let getGamepadData = () => {
        let gamepad = navigator.getGamepads()[0];
        if (gamepad === undefined || gamepad === null) return;

        let deadzone = 0.065;
        for (let i=0; i<gamepad.axes.length; i++)
          if (MyMath.abs(gamepad.axes[i]) >= deadzone) {
            gamepads.used.any = true;
            gamepads.used.axes.any = true;
            if (i === 0 || i === 1) gamepads.used.axes.left = true;
            if (i === 2 || i === 3) gamepads.used.axes.right = true;

            gamepads.output.axes = gamepad.axes;
          }

        let gobl = Object.entries(gamepads.output.buttons).length;
        for (let i=0; i<gamepad.buttons.length; i++)
          if (gamepad.buttons[i].pressed || (i < gobl && gamepad.buttons[i].pressed !== Object.entries(gamepads.output.buttons)[i][1].pressed)) {
            gamepads.used.any = true;
            gamepads.used.buttons = true;
          }

        gamepads.output.buttons.south = gamepad.buttons[0];
        gamepads.output.buttons.east = gamepad.buttons[1];
        gamepads.output.buttons.west = gamepad.buttons[2];
        gamepads.output.buttons.north = gamepad.buttons[3];

        gamepads.output.buttons.pause = gamepad.buttons[9];

        gamepads.output.buttons.dpad.up = gamepad.buttons[12];
        gamepads.output.buttons.dpad.right = gamepad.buttons[15];
        gamepads.output.buttons.dpad.left = gamepad.buttons[14];
        gamepads.output.buttons.dpad.down = gamepad.buttons[13];
      }
      let renderGamepad = () => {
        let joyStickRadius = swemu.joycon.width/5;
        let buttonRadius = swemu.joycon.width/10;
        let pressedShrinkRadius = 2.5;

        // Left JoyCon
        let joyStickCenterLeft = new Point((swemu.joycon.width/2), (swemu.joycon.height/4));
        let joyStickPositionLeft = new Point(joyStickRadius*0.8*gamepads.output.axes[0], joyStickRadius*0.8*gamepads.output.axes[1]).add(joyStickCenterLeft);

        draw.static.setColor("00c3e3");
        draw.static.rect(new Point(-joyStickRadius*2, -joyStickRadius*2).add(joyStickCenterLeft), new Point(joyStickRadius*2, joyStickRadius*2).add(joyStickCenterLeft));

        draw.static.setColor("212528");
        draw.static.arc(joyStickCenterLeft, joyStickRadius-10, false);
        draw.static.arc(joyStickCenterLeft, joyStickRadius-12, false);
        draw.static.arc(joyStickCenterLeft, joyStickRadius-14, false);
        draw.static.arc(joyStickPositionLeft, joyStickRadius);

        // Left Buttons
        let buttonCenterLeft = new Point((swemu.joycon.width/2), (swemu.joycon.height/2));

        draw.static.setColor("00c3e3");
        draw.static.rect(new Point(-buttonRadius*3, -buttonRadius*3).add(buttonCenterLeft), new Point(buttonRadius*3, buttonRadius*3).add(buttonCenterLeft));

        draw.static.setColor("212528");
        draw.static.arc(new Point(0, -buttonRadius*2).add(buttonCenterLeft), buttonRadius-(gamepads.output.buttons.dpad.up.pressed ? pressedShrinkRadius : 0));
        draw.static.arc(new Point(buttonRadius*2, 0).add(buttonCenterLeft), buttonRadius-(gamepads.output.buttons.dpad.right.pressed ? pressedShrinkRadius : 0));
        draw.static.arc(new Point(0, buttonRadius*2).add(buttonCenterLeft), buttonRadius-(gamepads.output.buttons.dpad.down.pressed ? pressedShrinkRadius : 0));
        draw.static.arc(new Point(-buttonRadius*2, 0).add(buttonCenterLeft), buttonRadius-(gamepads.output.buttons.dpad.left.pressed ? pressedShrinkRadius : 0));

        // Right JoyCon
        let joyStickCenterRight = new Point((swemu.joycon.width/2), (swemu.joycon.height/2)).add(points.redJoyConStart);
        let joyStickPositionRight = new Point(joyStickRadius*0.8*gamepads.output.axes[2], joyStickRadius*0.8*gamepads.output.axes[3]).add(joyStickCenterRight);

        draw.static.setColor("e60012");
        draw.static.rect(new Point(-joyStickRadius*2, -joyStickRadius*2).add(joyStickCenterRight), new Point(joyStickRadius*2, joyStickRadius*2).add(joyStickCenterRight));

        draw.static.setColor("212528");
        draw.static.arc(joyStickCenterRight, joyStickRadius-10, false);
        draw.static.arc(joyStickCenterRight, joyStickRadius-12, false);
        draw.static.arc(joyStickCenterRight, joyStickRadius-14, false);
        draw.static.arc(joyStickPositionRight, joyStickRadius);

        // Right Buttons
        let buttonCenterRight = new Point((swemu.joycon.width/2), (swemu.joycon.height/4)).add(points.redJoyConStart);

        draw.static.setColor("e60012");
        draw.static.rect(new Point(-buttonRadius*3, -buttonRadius*3).add(buttonCenterRight), new Point(buttonRadius*3, buttonRadius*3).add(buttonCenterRight));

        draw.static.setColor("212528");
        draw.static.arc(new Point(0, -buttonRadius*2).add(buttonCenterRight), buttonRadius-(gamepads.output.buttons.north.pressed ? pressedShrinkRadius : 0));
        draw.static.arc(new Point(buttonRadius*2, 0).add(buttonCenterRight), buttonRadius-(gamepads.output.buttons.east.pressed ? pressedShrinkRadius : 0));
        draw.static.arc(new Point(0, buttonRadius*2).add(buttonCenterRight), buttonRadius-(gamepads.output.buttons.south.pressed ? pressedShrinkRadius : 0));
        draw.static.arc(new Point(-buttonRadius*2, 0).add(buttonCenterRight), buttonRadius-(gamepads.output.buttons.west.pressed ? pressedShrinkRadius : 0));

        draw.static.setColor("212528");
        //draw.static.setColor("dada34");
        draw.static.arc(new Point(0, -buttonRadius*2).add(buttonCenterRight), buttonRadius-2-(gamepads.output.buttons.north.pressed ? pressedShrinkRadius : 0));
        //draw.static.setColor("da3434");
        draw.static.arc(new Point(buttonRadius*2, 0).add(buttonCenterRight), buttonRadius-2-(gamepads.output.buttons.east.pressed ? pressedShrinkRadius : 0));
        //draw.static.setColor("34da34");
        draw.static.arc(new Point(0, buttonRadius*2).add(buttonCenterRight), buttonRadius-2-(gamepads.output.buttons.south.pressed ? pressedShrinkRadius : 0));
        //draw.static.setColor("3434da");
        draw.static.arc(new Point(-buttonRadius*2, 0).add(buttonCenterRight), buttonRadius-2-(gamepads.output.buttons.west.pressed ? pressedShrinkRadius : 0));

        if (!gamepads.used.any) return;
        if (mouse.released) return; // return for now === only draw vgamepad (mouse pressed)

        draw.vgamepad.setColor("ffffff");
        draw.vgamepad.arc(mouse.pressedPosition, gamepads.virtual.renderRadius, false);
        draw.vgamepad.arc(mouse.pressedPosition, gamepads.virtual.renderRadius / 20, false);

        draw.vgamepad.arc(new Point(gamepads.output.axes[0] * gamepads.virtual.renderRadius, gamepads.output.axes[1] * gamepads.virtual.renderRadius).add(mouse.pressedPosition), gamepads.virtual.renderRadius / 3, false);
      }

      // Init listeners
      window.addEventListener("gamepadconnected",    event => {gamepadHandler(event, true );}, false);
      window.addEventListener("gamepaddisconnected", event => {gamepadHandler(event, false);}, false);
      document.onmousemove = mouseMoveHandler;
      document.ontouchmove = mouseMoveHandler;
      document.onmousedown = mouseClickHandler;
      document.ontouchdown = mouseClickHandler;
      document.onmouseup   = mouseClickHandler;
      document.ontouchup   = mouseClickHandler;

      // Static / One-Time render
      renderZoomInteraction();
      renderSwitch();

      let mainRenderer = () => {
        //if (currentGame !== null) requestAnimationFrame(mainRenderer);

        context.vgamepad.clearRect(0, 0, canvas.vgamepad.width, canvas.vgamepad.height);
        context.dynamic.clearRect(0, 0, canvas.dynamic.width, canvas.dynamic.height);

        // Reset .used state every update and let getVirtualGamepadData and getGamepadData update the value manually
        gamepads.used = {any: false, axes: {any: false, left: false, right: false}, buttons: false};
        gamepads.output.axes = [0, 0, 0, 0];
        getVirtualGamepadData();
        getGamepadData(); // Overwrite virtual data if this exists
        renderGamepad();

        getZoomInteraction();

        if (homeScreen._currentGame !== null) {
          if (homeScreen._paused) homeScreen._currentGame.renderGame(draw, gamepads, render);

          if (gamepads.output.buttons.east.pressed) {
            if (!gamepads.actions.east)
              homeScreen._currentGame.terminateGame();
            gamepads.actions.east = true;
          } else gamepads.actions.east = false;
        }

        homeScreen.render(draw, gamepads, render);

        let now = Date.now();
        render.deltaTime = (now - render.now) / 1000;
        render.now = now;
        if (render.input.verbose && render.input.updated) {
          render.input.delay = Date.now() - render.input.now;
          console.log(render.input.delay);
          render.input.updated = false;
        }

        requestAnimationFrame(mainRenderer);
      }

      let homeScreen = new HomeScreen(swemu);
      homeScreen.init(internals);

      render.now = Date.now();
      requestAnimationFrame(mainRenderer);
    </script>
  </body>
</html>
